//Libraries.
INCLUDE "%WEIDU_LIBRARY_DIR%/2da.tpa"
INCLUDE "%WEIDU_LIBRARY_DIR%/arrays.tpa"
INCLUDE "%WEIDU_LIBRARY_DIR%/generic.tpa"


//Basic functions.
DEFINE_DIMORPHIC_FUNCTION get_spell_size RET size BEGIN
    OUTER_SET size = 0x72
END

DEFINE_DIMORPHIC_FUNCTION get_spell_header_size RET size BEGIN
    OUTER_SET size = 0x28
END

//Constants.
//Tables.
LAF load_offsets_table STR_VAR
    file = "%WEIDU_LIBRARY_DIR%/resources/2da/spells/offsets.2da"
RET_ARRAY table_spl_offsets = table END

LAF load_offsets_table STR_VAR
    file = "%WEIDU_LIBRARY_DIR%/resources/2da/spells/header_offsets.2da"
RET_ARRAY table_spl_header_offsets = table END

//Indexes.
LAF array_from_table STR_VAR
    table = "table_spl_offsets"
    key = "field"
    value = "offset"
RET_ARRAY spl_offsets = array END

LAF array_from_table STR_VAR
    table = "table_spl_offsets"
    key = "field"
    value = "reader"
RET_ARRAY spl_readers = array END

LAF array_from_table STR_VAR
    table = "table_spl_offsets"
    key = "field"
    value = "writer"
RET_ARRAY spl_writers = array END

LAF array_from_table STR_VAR
    table = "table_spl_header_offsets"
    key = "field"
    value = "offset"
RET_ARRAY spl_header_offsets = array END

LAF array_from_table STR_VAR
    table = "table_spl_header_offsets"
    key = "field"
    value = "reader"
RET_ARRAY spl_header_readers = array END

LAF array_from_table STR_VAR
    table = "table_spl_header_offsets"
    key = "field"
    value = "writer"
RET_ARRAY spl_header_writers = array END


//Arrays.
LAF load_array STR_VAR
    table = "%WEIDU_LIBRARY_DIR%/resources/2da/spells/types.2da"
RET_ARRAY spell_types = array END

LAF load_array STR_VAR
    table = "%WEIDU_LIBRARY_DIR%/resources/2da/spells/flags.2da"
RET_ARRAY spell_flags = array END


//Basic reading functions.
DEFINE_PATCH_FUNCTION get_spell_header_count RET count BEGIN
    READ_SHORT 0x68 count
END

DEFINE_PATCH_FUNCTION get_spell_headers_offset RET offset BEGIN
    READ_LONG 0x64 offset
END

DEFINE_PATCH_FUNCTION get_spell_opcodes_offset RET offset BEGIN
    READ_LONG 0x6a offset
END

DEFINE_PATCH_FUNCTION get_casting_opcode_count RET count BEGIN
    READ_SHORT 0x70 count
END

//Getters.
DEFINE_DIMORPHIC_FUNCTION get_spell_res STR_VAR spell = "" RET resource BEGIN
    //Protect against garbage.
    OUTER_SET id = IDS_OF_SYMBOL ("spell" "%spell%")

    OUTER_TEXT_SPRINT resource "*"
    ACTION_IF NOT (0 - 1 = id) BEGIN
        LAF RES_NUM_OF_SPELL_NAME STR_VAR spell_name = "%spell%" RET resource = spell_res END
    END

    //Avoid casing problems.
    ACTION_TO_LOWER resource
END

DEFINE_DIMORPHIC_FUNCTION get_spell_type_id STR_VAR type = "" RET id BEGIN
    //Lower-case to avoid trivial mismatches.
    ACTION_TO_LOWER type
    OUTER_TEXT_SPRINT type_id $"spell_types"("%type%")

    OUTER_SET id = 0 - 1
    ACTION_IF IS_AN_INT type_id BEGIN
        OUTER_SET id = type_id
    END
END

DEFINE_DIMORPHIC_FUNCTION get_spell_school_id STR_VAR school = "" RET id BEGIN
    //Get school.
    COPY_EXISTING - "mschool.2da" "override"
        LPF find_row_index STR_VAR key = "%school%" RET id = index END
    
    //Correct index to account for 2DA spurious line.
    ACTION_IF NOT (0 - 1 = id) BEGIN
        OUTER_SET id -= 1
    END
END


//Casting opcode functions.
DEFINE_PATCH_FUNCTION get_casting_opcode_offset INT_VAR index = 0 RET offset BEGIN
    LPF get_opcode_size RET opcode_size = size END
    offset = 0 - 1

    LPF get_casting_opcode_count RET opcode_count = count END
    PATCH_IF (0 <= index) AND (index < opcode_count) BEGIN
        LPF get_spell_opcodes_offset RET op_start = offset END
        //Read index into equipped opcodes block: should be zero.
        READ_SHORT 0x6e op_index
        offset = op_start + (op_index + index) * opcode_size
    END
END


//Spell header functions.
DEFINE_PATCH_FUNCTION get_spell_header_offset INT_VAR header = 0 RET offset BEGIN
    LPF get_spell_header_size RET spell_header_size = size END
    LPF get_spell_header_count RET headers_count = count END
    LPF get_spell_headers_offset RET headers_offset = offset END
    offset = 0 - 1

    PATCH_IF (0 <= header ) AND (header < headers_count) BEGIN
        offset = headers_offset + (header * spell_header_size)
    END
END

//Header mutators.
DEFINE_PATCH_FUNCTION insert_spell_header INT_VAR index = 0 BEGIN
    //Normalize.
    LPF get_spell_header_count RET header_count = count END
    PATCH_IF (0 - 1 = index) BEGIN
        index = header_count
    END

    //Sanitize.
    PATCH_IF NOT ((0 <= index) AND (index <= header_count)) BEGIN
        PATCH_FAIL "insert_spell_header: '%index%' not in the range [-1, %header_count%]."
    END

    //Insert offset.
    LPF get_spell_header_size RET header_size = size END
    LPF get_spell_headers_offset RET fx_start = offset END
    ins_offset = fx_start + (header_size * index)

    //Insert opcode.
    INSERT_BYTES ins_offset header_size

    //Correct header amount and opcodes block offset.
    WRITE_SHORT 0x68 (THIS + 1)
    WRITE_LONG 0x6a (THIS + header_size)

    //Fill header fields.
    PATCH_IF (0 = index) BEGIN
        start_index = 0
        LPF get_casting_opcode_count RET amount = count END
    END ELSE BEGIN
        LPF get_spell_header_offset INT_VAR header = i - 1 RET pre_offset = offset END
        READ_SHORT (pre_offset + 0x20) start_index
        READ_SHORT (pre_offset + 0x1e) amount
    END
    WRITE_SHORT (ins_offset + 0x20) (start_index + amount)
    WRITE_BYTE ins_offset 1
END

DEFINE_PATCH_FUNCTION append_spell_header BEGIN
    LPF insert_spell_header INT_VAR index = 0 - 1 END
END


//Spell header opcode functions.
DEFINE_PATCH_FUNCTION get_spell_header_opcode_count INT_VAR header = 0 RET count BEGIN
    LPF get_spell_header_offset INT_VAR header = header RET header_offset = offset END
    count = 0 - 1

    PATCH_IF NOT (header_offset = 0 - 1) BEGIN
        //Read from opcode count field.
        READ_SHORT (header_offset + 0x1e) count
    END
END

DEFINE_PATCH_FUNCTION get_spell_header_opcode_block_offset INT_VAR header = 0 RET offset BEGIN
    LPF get_opcode_size RET opcode_size = size END
    LPF get_spell_header_offset INT_VAR header = header RET header_offset = offset END
    offset = 0 - 1

    PATCH_IF NOT (header_offset = 0 - 1) BEGIN
        LPF get_spell_opcodes_offset RET op_start = offset END
        //Read from opcode index field.
        READ_SHORT (header_offset + 0x20) op_index
        offset = op_start + op_index * opcode_size
    END
END

DEFINE_PATCH_FUNCTION get_spell_header_opcode_offset INT_VAR header = 0 index = 0 RET offset BEGIN
    LPF get_opcode_size RET opcode_size = size END
    LPF get_spell_header_offset INT_VAR header = header RET header_offset = offset END
    offset = 0 - 1

    PATCH_IF NOT (header_offset = 0 - 1) BEGIN
        LPF get_spell_header_opcode_count INT_VAR header = header RET op_count = count END
        PATCH_IF (0 <= index) AND (index < op_count) BEGIN
            LPF get_spell_opcodes_offset RET op_start = offset END
            //Read from opcode index field.
            READ_SHORT (header_offset + 0x20) op_index
            offset = op_start + (op_index + index) * opcode_size
        END
    END
END

//Readers and writers.
DEFINE_PATCH_FUNCTION get_spell_field STR_VAR field = "" RET value BEGIN
    LPF get_field_at INT_VAR
        offset = 0
    STR_VAR
        field = "%field%"
        offsets = "spl_offsets"
        readers = "spl_readers"
    RET value END
END

DEFINE_PATCH_FUNCTION set_spell_field STR_VAR field = "" value = "" BEGIN
    LPF set_field_at INT_VAR
        offset = 0
    STR_VAR
        field = "%field%"
        offsets = "spl_offsets"
        writers = "spl_writers"
        value = "%value%"
    END
END

DEFINE_PATCH_FUNCTION get_spell_header_field INT_VAR header = 0 STR_VAR field = "" RET value BEGIN
    LPF get_spell_header_offset INT_VAR
        header = header
    RET offset END

    //Sanitize.
    PATCH_IF (0 - 1 = offset) BEGIN
        PATCH_FAIL "get_spell_header_field: header '%header%' out of bounds."
    END

    LPF get_field_at INT_VAR
        offset = offset
    STR_VAR
        field = "%field%"
        offsets = "spl_header_offsets"
        readers = "spl_header_readers"
    RET value END
END

DEFINE_PATCH_FUNCTION set_spell_header_field INT_VAR header = 0 STR_VAR field = "" value = "" BEGIN
    LPF get_spell_header_offset INT_VAR
        header = header
    RET offset END

    //Sanitize.
    PATCH_IF (0 - 1 = offset) BEGIN
        PATCH_FAIL "set_spell_header_field: header '%header%' out of bounds."
    END

    LPF set_field_at INT_VAR
        offset = offset
    STR_VAR
        field = "%field%"
        offsets = "spl_header_offsets"
        writers = "spl_header_writers"
        value = "%value%"
    END
END

//Convenience spell patchers.
DEFINE_PATCH_FUNCTION set_spell_header_fields STR_VAR field = "" value = "" BEGIN
    LPF get_spell_header_count RET header_count = count END
    FOR (i = 0; i < header_count; ++i) BEGIN
        LPF set_spell_header_field INT_VAR
            header = i
        STR_VAR
            field = "%field%"
            value = "%value%"
        END
    END
END

//Mutators.
DEFINE_PATCH_FUNCTION insert_spell_casting_opcode INT_VAR index = 0 BEGIN
    //Normalize.
    LPF get_casting_opcode_count RET op_count = count END
    PATCH_IF (0 - 1 = index) BEGIN
        index = op_count
    END

    //Sanitize.
    PATCH_IF NOT ((0 <= index) AND (index <= op_count)) BEGIN
        PATCH_FAIL "insert_spell_casting_opcode: '%index%' not in the range [-1, %op_count%]."
    END

    //Insert offset.
    LPF get_opcode_size RET op_size = size END
    LPF get_spell_opcodes_offset RET fx_start = offset END
    ins_offset = fx_start + (op_size * index)

    //Insert opcode.
    INSERT_BYTES ins_offset op_size

    //Adjust opcode count.
    WRITE_SHORT 0x70 (THIS + 1)

    //Adjust header opcode indices.
    LPF get_spell_header_count RET headers_count = count END
    PATCH_IF NOT (headers_count = 0) BEGIN
        LPF get_spell_headers_offset RET fx_start = offset END
        LPF get_spell_header_size RET header_size = size END
        FOR (i = 0; i < headers_count; ++i) BEGIN
            WRITE_SHORT (fx_start + (i * header_size) + 0x20) (THIS + 1)
        END
    END

    //Write probability1.
    LPF set_opcode_field INT_VAR
        offset = ins_offset
    STR_VAR
        field = "probability1"
        value = "100"
    END
END

DEFINE_PATCH_FUNCTION append_spell_casting_opcode BEGIN
    LPF insert_spell_casting_opcode INT_VAR index = 0 - 1 END
END

DEFINE_PATCH_FUNCTION insert_spell_header_opcode INT_VAR header = 0 index = 0 BEGIN
    //Sanitize.
    LPF get_spell_header_count RET headers_count = count END
    PATCH_IF NOT ((0 <= header) AND (header < headers_count)) BEGIN
        PATCH_FAIL "insert_spell_header_opcode: header '%header%' not in the range [0, %headers_count%[."
    END

    //Normalize and sanitize.
    LPF get_spell_header_opcode_count INT_VAR header = header RET op_count = count END
    PATCH_IF (0 - 1 = index) BEGIN
        index = op_count
    END
    PATCH_IF NOT ((0 <= index) AND (index <= op_count)) BEGIN
        PATCH_FAIL "insert_spell_header_opcode: '%index%' not in the range [-1, %op_count%]."
    END

    LPF get_opcode_size RET op_size = size END
    LPF get_spell_header_opcode_block_offset INT_VAR header = header RET fx_start = offset END
    ins_offset = fx_start + (op_size * index)

    //Insert opcode.
    INSERT_BYTES ins_offset op_size

    //Adjust header opcode count.
    LPF get_spell_header_offset INT_VAR header = header RET fx_start = offset END
    WRITE_SHORT (fx_start + 0x1e) (THIS + 1)

    //Adjust opcode block indices.
    LPF get_spell_headers_offset RET header_offset = offset END
    LPF get_spell_header_size RET header_size = size END
    FOR (i = header + 1; i < headers_count; ++i) BEGIN
        WRITE_SHORT (fx_start + (i * header_size) + 0x20) (THIS + 1)
    END

    //Write probability1.
    LPF set_opcode_field INT_VAR
        offset = ins_offset
    STR_VAR
        field = "probability1"
        value = "100"
    END
END

DEFINE_PATCH_FUNCTION append_spell_header_opcode INT_VAR header = 0 BEGIN
    LPF insert_spell_header_opcode INT_VAR
        header = header
        index = 0 - 1
    END
END


//Block mutators.
DEFINE_PATCH_FUNCTION insert_spell_casting_block INT_VAR index = 0 amount = 1 BEGIN
    //Normalize.
    LPF get_casting_opcode_count RET op_count = count END
    PATCH_IF (0 - 1 = index) BEGIN
        index = op_count
    END

    //Sanitize.
    PATCH_IF NOT ((0 <= index) AND (index <= op_count)) BEGIN
        PATCH_FAIL "insert_spell_casting_block: '%index%' not in the range [-1, %op_count%]."
    END

    PATCH_IF (amount < 1) BEGIN
        PATCH_FAIL "insert_spell_casting_block: amount '%amount%' is not strictly positive."
    END

    //Insert offset.
    LPF get_opcode_size RET op_size = size END
    LPF get_spell_opcodes_offset RET fx_start = offset END
    ins_offset = fx_start + (op_size * index)

    //Insert opcode.
    INSERT_BYTES ins_offset (op_size * amount)

    //Adjust opcode count.
    WRITE_SHORT 0x70 (THIS + amount)

    //Adjust header opcode indices.
    LPF get_spell_header_count RET headers_count = count END
    PATCH_IF NOT (headers_count = 0) BEGIN
        LPF get_spell_headers_offset RET fx_start = offset END
        LPF get_spell_header_size RET header_size = size END
        FOR (i = 0; i < headers_count; ++i) BEGIN
            WRITE_SHORT (fx_start + (i * header_size) + 0x20) (THIS + amount)
        END
    END

    //Write probability1.
    FOR (i = 0; i < amount; ++i) BEGIN
        LPF set_opcode_field INT_VAR
            offset = ins_offset + (i * op_size)
        STR_VAR
            field = "probability1"
            value = "100"
        END
    END
END

DEFINE_PATCH_FUNCTION append_spell_casting_block INT_VAR amount = 1 BEGIN
    LPF insert_spell_casting_block INT_VAR
        index = 0 - 1
        amount = amount
    END
END

DEFINE_PATCH_FUNCTION insert_spell_header_block INT_VAR header = 0 index = 0 amount = 1 BEGIN
    //Sanitize.
    LPF get_spell_header_count RET headers_count = count END
    PATCH_IF NOT ((0 <= header) AND (header < headers_count)) BEGIN
        PATCH_FAIL "insert_spell_header_block: header '%header%' not in the range [0, %headers_count%[."
    END

    //Normalize and sanitize.
    LPF get_spell_header_opcode_count INT_VAR header = header RET op_count = count END
    PATCH_IF (0 - 1 = index) BEGIN
        index = op_count
    END
    PATCH_IF NOT ((0 <= index) AND (index <= op_count)) BEGIN
        PATCH_FAIL "insert_spell_header_block: '%index%' not in the range [-1, %op_count%]."
    END

    PATCH_IF (amount < 1) BEGIN
        PATCH_FAIL "insert_spell_header_block: amount '%amount%' is not strictly positive."
    END

    LPF get_opcode_size RET op_size = size END
    LPF get_spell_header_opcode_block_offset INT_VAR header = header RET fx_start = offset END
    ins_offset = fx_start + (op_size * index)

    //Insert opcode.
    INSERT_BYTES ins_offset (op_size * amount)

    //Adjust header opcode count.
    LPF get_spell_header_offset INT_VAR header = header RET fx_start = offset END
    WRITE_SHORT (fx_start + 0x1e) (THIS + amount)

    //Adjust opcode block indices.
    LPF get_spell_headers_offset RET header_offset = offset END
    LPF get_spell_header_size RET header_size = size END
    FOR (i = header + 1; i < headers_count; ++i) BEGIN
        WRITE_SHORT (fx_start + (i * header_size) + 0x20) (THIS + amount)
    END

    //Write probability1.
    FOR (i = 0; i < amount; ++i) BEGIN
        LPF set_opcode_field INT_VAR
            offset = ins_offset + (i * op_size)
        STR_VAR
            field = "probability1"
            value = "100"
        END
    END
END

DEFINE_PATCH_FUNCTION append_spell_header_block INT_VAR header = 0 amount = 1 BEGIN
    LPF insert_spell_header_block INT_VAR
        header = header
        index = 0 - 1
        amount = amount
    END
END
